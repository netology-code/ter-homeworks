# Домашнее задание к занятию «Управляющие конструкции в коде Terraform»

### Цели задания

1. Отработать основные принципы и методы работы с управляющими конструкциями Terraform.
2. Освоить работу с шаблонизатором Terraform (Interpolation Syntax).

------

### Чек-лист готовности к домашнему заданию

1. Зарегистрирован аккаунт в Yandex Cloud. Использован промокод на грант.
2. Установлен инструмент Yandex CLI.
3. Доступен исходный код для выполнения задания в директории [**03/src**](https://github.com/netology-code/ter-homeworks/tree/main/03/src).
4. Любые ВМ, использованные при выполнении задания, должны быть прерываемыми, для экономии средств.

------

### Внимание!! Обязательно предоставляем на проверку получившийся код в виде ссылки на ваш github-репозиторий!
Убедитесь что ваша версия **Terraform** ~>1.12.0
Теперь пишем красивый код, хардкод значения не допустимы!
------
ssh -l alexlinux 158.160.37.177
sudo apt update && sudo apt install wget -y

wget https://hashicorp-releases.yandexcloud.net/terraform/1.12.0/terraform_1.12.0_linux_amd64.zip

sudo apt update
sudo apt install unzip -y

unzip terraform_1.12.0_linux_amd64.zip
sudo mv terraform /usr/local/bin/

curl -sSL https://storage.yandexcloud.net/yandexcloud-yc/install.sh | bash

nano ~/.terraformrc

provider_installation {
  network_mirror {
    url = "https://terraform-mirror.yandexcloud.net/"
    include = ["registry.terraform.io/*/*"]
  }
  direct {
    exclude = ["registry.terraform.io/*/*"]
  }
}

ls -la ~/.terraformrc

cat ~/.terraformrc

mkdir ~/terraform-project

cd ~/terraform-project

scp -i "C:/Users/IRU/.ssh/id_ed25519" "C:/distr/Distr_Terr/authorized_key.json" alexlinux@158.160.37.177:/home/alexlinux/

scp "C:\\distr\\Distr_Terr\\authorized_key.json" alexlinux@158.160.37.177:/home/

cd ~
git clone https://github.com/sapr797/ter-homeworks

cd terraform-project

cd ~/terraform-project

terraform init
terraform plan

yc iam create-token

nano provider.tf

terraform {
  required_providers {
    yandex = {
      source = "yandex-cloud/yandex"
    }
  }
  required_version = "~>1.12.0"
}

provider "yandex" {
  token     = var.token
  cloud_id  = var.cloud_id
  folder_id = var.folder_id
  zone      = var.default_zone
}

yc init

https://github.com/sapr797/ter-homeworks/tree/main/03/src

### Задание 1

1. Изучите проект.
2. Инициализируйте проект, выполните код. 


Приложите скриншот входящих правил «Группы безопасности» в ЛК Yandex Cloud .

------

### Задание 2

1. Создайте файл count-vm.tf. Опишите в нём создание двух **одинаковых** ВМ  web-1 и web-2 (не web-0 и web-1) с минимальными параметрами, используя мета-аргумент **count loop**. Назначьте ВМ созданную в первом задании группу безопасности.(как это сделать узнайте в документации провайдера yandex/compute_instance )
2. Создайте файл for_each-vm.tf. Опишите в нём создание двух ВМ для баз данных с именами "main" и "replica" **разных** по cpu/ram/disk_volume , используя мета-аргумент **for_each loop**. Используйте для обеих ВМ одну общую переменную типа:
```
variable "each_vm" {
  type = list(object({  vm_name=string, cpu=number, ram=number, disk_volume=number }))
}
```  
При желании внесите в переменную все возможные параметры.
4. ВМ из пункта 2.1 должны создаваться после создания ВМ из пункта 2.2.
5. Используйте функцию file в local-переменной для считывания ключа ~/.ssh/id_rsa.pub и его последующего использования в блоке metadata, взятому из ДЗ 2.
6. Инициализируйте проект, выполните код.

------

1.  nano count-vm.tf

resource "yandex_compute_instance" "web" {
  count = 2
  name  = "web-${count.index + 1}"

  resources {
    cores  = 2
    memory = 2
  }

  boot_disk {
    initialize_params {
      image_id = "fd8fhirjb21am2sv9aud"  # ID образа Ubuntu
      size     = 10
    }
  }

  network_interface {
    subnet_id = "e9bproja629hr9doud9c"  # ID подсети terraform-subnet
    nat       = true
    security_group_ids = ["enpcf56b6oforfoso9vb"]  # ID группы безопасности для сети terraform-subnet
  }

  metadata = {
    ssh-keys = "ubuntu:${file("~/.ssh/id_rsa.pub")}"
  }
}


Подсеть: e9bproja629hr9doud9c (terraform-subnet) - имеет диапазон 192.168.10.0/24
Группа безопасности: enpcf56b6oforfoso9vb - группа по умолчанию для сети
terraform-subnet Образ: fd8fhirjb21am2sv9aud - Ubuntu 22.04 LTS

Просмотр доступных образов

yc compute image list --limit 10

# Для Ubuntu 22.04
yc compute image get-latest-from-family ubuntu-2204-lts --folder-id standard-images
# Или посмотреть все образы Ubuntu
yc compute image list --folder-id standard-images | grep ubuntu

Просмотр подсетей
Copy Download yc vpc subnet list

Просмотр групп безопасности
yc vpc security-group list



# Проверить синтаксис
terraform validate

# Посмотреть план создания
terraform plan

# Применить конфигурацию
terraform apply


#variables.tf
###cloud vars
variable "token" {
  type        = string
  description = "OAuth-token; https://cloud.yandex.ru/docs/iam/concepts/authorization/oauth-token"
}

variable "cloud_id" {
  type        = string
  description = "https://cloud.yandex.ru/docs/resource-manager/operations/cloud/get-id"
}

variable "folder_id" {
  type        = string
  description = "https://cloud.yandex.ru/docs/resource-manager/operations/folder/get-id"
}

variable "default_zone" {
  type        = string
  default     = "ru-central1-a"
  description = "https://cloud.yandex.ru/docs/overview/concepts/geo-scope"
}
variable "default_cidr" {
  type        = list(string)
  default     = ["10.0.1.0/24"]
  description = "https://cloud.yandex.ru/docs/vpc/operations/subnet-create"
}

variable "vpc_name" {
  type        = string
  default     = "develop"
  description = "VPC network&subnet name"
}

yc config list


#terraform.tfvars


# Получите эти значения из yc config
token     = "t1.9euelZqcyIq**********EubWAlZdujvUDA"
cloud_id  = "b***h9636b87" 
folder_id = "b*****eobjh"
default_zone = "ru-central1-a"



Добавьте terraform.tfvars в .gitignore чтобы не коммитить чувствительные данные:

echo "*.tfvars" >> .gitignore
echo "*.tfstate*" >> .gitignore
echo ".terraform/" >> .gitignore


terraform validate
terraform plan

Создайте новую пару SSH-ключей:
ssh-keygen -t rsa -b 2048 -f ~/.ssh/id_rsa -N ""

проверьте, что ключи создались:
ls -la ~/.ssh/id_rsa*


resource "tls_private_key" "ssh" {
  algorithm = "RSA"
  rsa_bits  = 2048
}

resource "yandex_compute_instance" "web" {
  count = 2
  name  = "web-${count.index + 1}"

  resources {
    cores  = 2
    memory = 2
  }

  boot_disk {
    initialize_params {
      image_id = "fd8fhirjb21am2sv9aud"
      size     = 10
    }
  }

  network_interface {
    subnet_id = "e9bproja629hr9doud9c"
    nat       = true
    security_group_ids = ["enpcf56b6oforfoso9vb"]
  }

  metadata = {
    ssh-keys = "ubuntu:${tls_private_key.ssh.public_key_openssh}"
  }
}

# Сохранить приватный ключ в файл
resource "local_file" "private_key" {
  content  = tls_private_key.ssh.private_key_pem
  filename = "${path.module}/ssh_key.pem"
  file_permission = "0600"
}

terraform init
terraform validate
terraform plan

применять конфигурацию:
terraform apply

Посмотреть созданные ВМ
yc compute instance list


загрузите публичный ключ вручную:
 # Получите публичный ключ
cat C:\Users\IRU\.ssh\id_rsa.pub


Проверить подключение по SSH: 

ssh -i ~/.ssh/id_rsa ubuntu@84.252.129.114
ssh -i ~/.ssh/id_rsa ubuntu@46.21.247.143
ssh -i ~/.ssh/id_rsa ubuntu@158.160.37.177
ssh -l  ubuntu 84.201.130.122

ssh -l  ubuntu@51.250.89.213

ssh-keygen -t rsa -b 2048 -f C:\Users\IRU\.ssh\id_rsa


Проверить какой ключ установлен на ВМ На Linux VM в Yandex Cloud выполните:
# Посмотреть какие ВМ созданы и их
IP yc compute instance list 
# Проверить подключение с Linux VM к новой ВМ
 ssh -i ~/.ssh/id_rsa ubuntu@84.201.130.122

Создать новый SSH-ключ на Linux VM

# Создаем новую пару ключей
ssh-keygen -t rsa -b 2048 -f ~/.ssh/terraform_key -N ""

# Смотрим публичный ключ
cat ~/.ssh/terraform_key.pub


ls -la ~/.ssh/terraform_key*

cat ~/.ssh/terraform_key.pub

terraform show

terraform show -json | jq '.values.root_module.resources[] | select(.type=="yandex_compute_instance") | {name: .values.name, metadata: .values.metadata}'

# Удалим текущие ВМ
terraform destroy

# Убедимся, что используем правильный ключ в конфигурации
cat count-vm.tf | grep ssh-keys

# Создадим ВМ заново
terraform apply

# Подключение с подробным выводом отладки
 ssh -i ~/.ssh/terraform_key -v ubuntu@84.201.130.122


# Показать приватный ключ
cat ~/.ssh/terraform_key


ssh -l ubuntu 51.250.8.206

ssh -l ubuntu 62.84.119.86

На Windows создайте новый SSH-ключ:


# В PowerShell
ssh-keygen -t rsa -b 2048 -f C:\Users\IRU\.ssh\terraform_key

# Показать публичный ключ
cat C:\Users\IRU\.ssh\terraform_key.pub

Скопируйте публичный ключ и обновите count-vm.tf на Linux VM:

hcl
metadata = {
  ssh-keys = "ubuntu:ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC...ВАШ_НОВЫЙ_КЛЮЧ_С_WINDOWS..."
}
Примените изменения на Linux VM:

bash
terraform apply

cat C:\Users\IRU\.ssh\terraform_key.pub

ssh -i C:\Users\IRU\.ssh\terraform_key ubuntu@862.84.119.86
ssh -l ubuntu 62.84.119.86

sudo nano /etc/resolv.conf

nameserver 8.8.8.8
nameserver 8.8.4.4

sudo systemctl restart systemd-resolved

ssh -l alexlinux 46.21.246.71
ssh -i ~/.ssh/terraform_key ubuntu@62.84.119.86
ssh -i ~/.ssh/terraform_key ubuntu@51.250.8.206

 cd terraform-project


Ключевые особенности
for_each loop: Преобразует список в map для использования в for_each

Разные параметры: ВМ "main" и "replica" имеют разные CPU, RAM, disk

Опциональные параметры: Используются значения по умолчанию через optional()

Гибкость: Легко добавлять новые ВМ в список переменных


terraform validate
terraform plan
terraform apply

ls -la ~/.ssh/id_rsa.pub

terraform validate
terraform plan



### Задание 3

1. Создайте 3 одинаковых виртуальных диска размером 1 Гб с помощью ресурса yandex_compute_disk и мета-аргумента count в файле **disk_vm.tf** .
2. Создайте в том же файле **одиночную**(использовать count или for_each запрещено из-за задания №4) ВМ c именем "storage"  . Используйте блок **dynamic secondary_disk{..}** и мета-аргумент for_each для подключения созданных вами дополнительных дисков.

------
#disk_vm.tf
resource "yandex_compute_disk" "storage" {
  count = 3

  name     = "storage-disk-${count.index}"
  type     = "network-hdd"
  zone     = "ru-central1-a"
  size     = 1
}

terraform plan
terraform apply

# Просмотр всех ресурсов
terraform show

# Просмотр конкретных ВМ
terraform state list | grep compute_instance
# Правильный формат - с кавычками
terraform state show 'yandex_compute_instance.database_vm["main"]'


Изменяем  # disk_vm.tf

Ключевые особенности
Одиночная ВМ: Ресурс yandex_compute_instance.storage без count/for_each

Dynamic block: dynamic "secondary_disk" с for_each для итерации по дискам

Автоматическое подключение: Все 3 созданных диска будут подключены к ВМ

Соответствие заданию: Используется for_each только в dynamic block, что разрешено

terraform validate
terraform plan
terraform apply











### Задание 4

1. В файле ansible.tf создайте inventory-файл для ansible.
Используйте функцию tepmplatefile и файл-шаблон для создания ansible inventory-файла из лекции.
Готовый код возьмите из демонстрации к лекции [**demonstration2**](https://github.com/netology-code/ter-homeworks/tree/main/03/demo).
Передайте в него в качестве переменных группы виртуальных машин из задания 2.1, 2.2 и 3.2, т. е. 5 ВМ.
2. Инвентарь должен содержать 3 группы и быть динамическим, т. е. обработать как группу из 2-х ВМ, так и 999 ВМ.

3. Добавьте в инвентарь переменную  [**fqdn**](https://cloud.yandex.ru/docs/compute/concepts/network#hostname).
``` 

[webservers]
web-1 ansible_host=<внешний ip-адрес> fqdn=<полное доменное имя виртуальной машины>
web-2 ansible_host=<внешний ip-адрес> fqdn=<полное доменное имя виртуальной машины>

[databases]
main ansible_host=<внешний ip-адрес> fqdn=<полное доменное имя виртуальной машины>
replica ansible_host<внешний ip-адрес> fqdn=<полное доменное имя виртуальной машины>

[storage]
storage ansible_host=<внешний ip-адрес> fqdn=<полное доменное имя виртуальной машины>
```
Пример fqdn: ```web1.ru-central1.internal```(в случае указания переменной hostname(не путать с переменной name)); ```fhm8k1oojmm5lie8i22a.auto.internal```(в случае отсутвия перменной hostname - автоматическая генерация имени,  зона изменяется на auto). нужную вам переменную найдите в документации провайдера или terraform console.
4. Выполните код. Приложите скриншот получившегося файла. 

Для общего зачёта создайте в вашем GitHub-репозитории новую ветку terraform-03. Закоммитьте в эту ветку свой финальный код проекта, пришлите ссылку на коммит.   
**Удалите все созданные ресурсы**.

------

4.1
terraform init -upgrade

#ansible.tf
# Динамический inventory для Ansible
resource "local_file" "ansible_inventory" {
  content = templatefile("inventory.tpl", {
    # Группа web - обрабатывает любое количество ВМ (2, 999, etc.)
    web_instances = [
      for vm in yandex_compute_instance.web : {
        name = vm.name
        ip   = vm.network_interface.0.nat_ip_address
      }
    ]
    
    # Группа db - обрабатывает любое количество ВМ  
    db_instances = [
      for vm_key, vm in yandex_compute_instance.database_vm : {
        name = vm.name
        ip   = vm.network_interface.0.nat_ip_address
      }
    ]
    
    # Группа storage - обрабатывает одну или несколько ВМ
    storage_instances = [
      {
        name = yandex_compute_instance.storage.name
        ip   = yandex_compute_instance.storage.network_interface.0.nat_ip_address
      }
    ]
  })
  filename = "${path.module}/inventory.ini"
}

#inventory.tpl

# Dynamic Ansible Inventory
# Generated automatically by Terraform

[web]
%{ for vm in web_instances ~}
${vm.name} ansible_host=${vm.ip} ansible_user=ubuntu
%{ endfor ~}

[db]
%{ for vm in db_instances ~}
${vm.name} ansible_host=${vm.ip} ansible_user=ubuntu
%{ endfor ~}

[storage]
%{ for vm in storage_instances ~}
${vm.name} ansible_host=${vm.ip} ansible_user=ubuntu
%{ endfor ~}

# All hosts group
[all:vars]
ansible_connection=ssh
ansible_user=ubuntu
ansible_ssh_private_key_file=~/.ssh/id_rsa

# Group specific variables
[web:vars]
role=web_server

[db:vars] 
role=database

[storage:vars]
role=storage

Ключевые особенности
Динамичность: Обрабатывает любое количество ВМ в каждой группе (2, 999, 1)

Автоматизация: Не требует ручного редактирования при добавлении/удалении ВМ

Группировка: 3 отдельные группы [web], [db], [storage]

Готовность к использованию: Содержит все необходимые переменные Ansible


terraform apply
cat inventory.ini


FQDN в Yandex Cloud
Атрибут fqdn возвращает полное доменное имя виртуальной машины в одном из двух форматов, которые вы указали:

Если задана переменная hostname: hostname.ru-central1.internal

Если hostname не задан: идентификатор-виртуальной-машины.auto.internal

Это внутреннее DNS-имя, которое автоматически управляется платформой Yandex Cloud

посмотреть значение fqdn для  виртуальной машины
terraform state show 'yandex_compute_instance.web[0]' | grep fqdn 

Или  созданной через for_each: bash Copy Download terraform state show 'yandex_compute_instance.database_vm["main"]' | grep fqdn

посмотреть значение fqdn для конкретной виртуальной машины с помощью команды:

terraform state show 'yandex_compute_instance.web[0]' | grep fqdn
Или для ВМ, созданной через for_each:

bash
terraform state show 'yandex_compute_instance.database_vm["main"]' | grep fqdn

# Просмотреть содержимое файла
cat inventory.ini

# Или с нумерацией строк
cat -n inventory.ini

# Или с постраничным просмотром
less inventory.ini

# Показать только определенные группы
grep -A 10 "\[webservers\]" inventory.ini



sudo apt update
sudo apt install ansible-core


git checkout -b terraform-03


git remote remove origin
git remote add origin https://github.com/sapr797/ter-homeworks.git
git push -u origin terraform-03

ssh-keygen -t ed25519 -C "eferk@bk.ru"

git remote set-url origin git@github.com:sapr797/ter-homeworks.git
ssh -T git@github.com

git push -u origin terraform-03

https://github.com/sapr797/ter-homeworks/tree/terraform-03

https://github.com/sapr797/terraform-homework-03

https://github.com/sapr797/ter-homeworks/pull/new/terraform-03
https://github.com/netology-code/ter-homeworks/compare/main...sapr797:ter-homeworks:terraform-03?expand=1


## Дополнительные задания (со звездочкой*)

**Настоятельно рекомендуем выполнять все задания со звёздочкой.** Они помогут глубже разобраться в материале.   
Задания со звёздочкой дополнительные, не обязательные к выполнению и никак не повлияют на получение вами зачёта по этому домашнему заданию. 

### Задание 5* (необязательное)
1. Напишите output, который отобразит ВМ из ваших ресурсов count и for_each в виде списка словарей :
``` 
[
 {
  "name" = 'имя ВМ1'
  "id"   = 'идентификатор ВМ1'
  "fqdn" = 'Внутренний FQDN ВМ1'
 },
 {
  "name" = 'имя ВМ2'
  "id"   = 'идентификатор ВМ2'
  "fqdn" = 'Внутренний FQDN ВМ2'
 },
 ....
...итд любое количество ВМ в ресурсе(те требуется итерация по ресурсам, а не хардкод) !!!!!!!!!!!!!!!!!!!!!
]
```
Приложите скриншот вывода команды ```terrafrom output```.

------

terraform apply

terraform output all_vms
ls -la outputs.tf
cat outputs.tf

terraform validate
terraform output

Когда output будет создан, выполните для скриншота:
terraform output all_vms
terraform output -json all_vms | jq .

cat outputs.tf
terraform validate
terraform apply -auto-approve
mkdir -p templates


cat > templates/inventory.tpl << 'EOF'
[webservers]
%{for ip in webservers ~}
${ip}
%{endfor ~}

[webservers:vars]
ansible_ssh_user=ubuntu
ansible_ssh_private_key_file=~/.ssh/your_key.pem
ansible_ssh_common_args='-o StrictHostKeyChecking=no'
EOF





### Задание 6* (необязательное)

1. Используя null_resource и local-exec, примените ansible-playbook к ВМ из ansible inventory-файла.
Готовый код возьмите из демонстрации к лекции [**demonstration2**](https://github.com/netology-code/ter-homeworks/tree/main/03/demo).
3. Модифицируйте файл-шаблон hosts.tftpl. Необходимо отредактировать переменную ```ansible_host="<внешний IP-address или внутренний IP-address если у ВМ отсутвует внешний адрес>```.

Для проверки работы уберите у ВМ внешние адреса(nat=false). Этот вариант используется при работе через bastion-сервер.
Для зачёта предоставьте код вместе с основной частью задания.

### Правила приёма работы

В своём git-репозитории создайте новую ветку terraform-03, закоммитьте в эту ветку свой финальный код проекта. Ответы на задания и необходимые скриншоты оформите в md-файле в ветке terraform-03.

В качестве результата прикрепите ссылку на ветку terraform-03 в вашем репозитории.

Важно. Удалите все созданные ресурсы.

### Задание 7* (необязательное)
Ваш код возвращает вам следущий набор данных: 
```
> local.vpc
{
  "network_id" = "enp7i560tb28nageq0cc"
  "subnet_ids" = [
    "e9b****n",
    "e2lb****a",
    "b0c******6pl",
    "fl********f0h",
  ]
  "subnet_zones" = [
    "ru-central1-a",
    "ru-central1-b",
    "ru-central1-c",
    "ru-central1-d",
  ]
}
```
Предложите выражение в terraform console, которое удалит из данной переменной 3 элемент из: subnet_ids и subnet_zones.(значения могут быть любыми) Образец конечного результата:
```
> <некое выражение>
{
  "network_id" = "enp7i560tb28nageq0cc"
  "subnet_ids" = [
    "e9b0*******n",
    "e2lba*****5hia",
    "fl8n******0h",
  ]
  "subnet_zones" = [
    "ru-central1-a",
    "ru-central1-b",
    "ru-central1-d",
  ]
}
```------------------------------

kill -9 1241
yc iam create-token

yc config get cloud-id
yc resource-manager folder list

cat > terraform.tfvars << 'EOF'
token     = "t*******voVTal5yDw"
cloud_id  = "b1g**636b87"
folder_id = "b1g*******2eobjh"
zone      = "ru-central1-a"
EOF

terraform validate
terraform plan
terraform apply -auto-approve


# Создать исправленный main.tf
cat > main.tf << 'EOF'
# main.tf - основной файл конфигурации

terraform {
  required_version = ">= 1.0"

  required_providers {
    yandex = {
      source  = "yandex-cloud/yandex"
      version = "~> 0.171.0"
    }
    local = {
      source  = "hashicorp/local"
      version = "~> 2.4"
    }
    null = {
      source  = "hashicorp/null"
      version = "~> 3.2"
    }
    template = {
      source  = "hashicorp/template"
      version = "~> 2.2"
    }
  }
}


# Создание сети
resource "yandex_vpc_network" "network" {
  name = "web-network"
}

# Создание подсети
resource "yandex_vpc_subnet" "subnet" {
  name           = "web-subnet"
  zone           = var.zone
  network_id     = yandex_vpc_network.network.id
  v4_cidr_blocks = ["192.168.10.0/24"]
}

# Создание security group в Yandex Cloud
resource "yandex_vpc_security_group" "web_sg" {
  name        = "web-sg"
  description = "Security group for web servers"
  network_id  = yandex_vpc_network.network.id

  ingress {
    protocol       = "TCP"
    port           = 22
    v4_cidr_blocks = ["0.0.0.0/0"]
  }

  ingress {
    protocol       = "TCP"
    port           = 80
    v4_cidr_blocks = ["0.0.0.0/0"]
  }

  ingress {
    protocol       = "TCP"
    port           = 443
    v4_cidr_blocks = ["0.0.0.0/0"]
  }

  egress {
    protocol       = "ANY"
    v4_cidr_blocks = ["0.0.0.0/0"]
  }
}

# Создание ВМ в Yandex Cloud
resource "yandex_compute_instance" "web_servers" {
  count = var.instance_count

  name        = "web-server-${count.index + 1}"
  platform_id = "standard-v3"
  zone        = var.zone

  allow_stopping_for_update = true  # ДОБАВИТЬ И ЗДЕСЬ

  resources {
    cores  = 2
    memory = 2
  }

  boot_disk {
    initialize_params {
      image_id = "fd87va5cc00gaq2f5qfb" # Ubuntu 20.04
    }
  }

  network_interface {
    subnet_id = yandex_vpc_subnet.subnet.id
    nat       = true
    security_group_ids = [yandex_vpc_security_group.web_sg.id]
  }

  metadata = {
    ssh-keys = "ubuntu:${file("~/.ssh/id_rsa.pub")}"
  }
}
EOF



yc compute image list --folder-id standard-images
yc vpc subnet list


# Создать минимальную рабочую конфигурацию
cat > minimal.tf << 'EOF'
terraform {
  required_providers {
    yandex = {
      source  = "yandex-cloud/yandex"
      version = "~> 0.171.0"
    }
  }
}

resource "yandex_compute_instance" "test" {
  name        = "test-vm"
  platform_id = "standard-v3"
  zone        = "ru-central1-a"

  resources {
    cores  = 2
    memory = 2
  }

  boot_disk {
    initialize_params {
      image_id = "fd80fofg3v5itrba3mv2"
    }
  }

  network_interface {
    subnet_id = "e9bproja629hr9doud9c"
    nat       = true
  }

  metadata = {
    ssh-keys = "ubuntu:${file("~/.ssh/id_rsa.pub")}"
  }
}
EOF


cat > locals.tf << 'EOF'
locals {
  vpc = {
    network_id   = data.yandex_vpc_network.existing.id
    subnet_ids   = [data.yandex_vpc_subnet.existing.id]
    subnet_zones = [data.yandex_vpc_subnet.existing.zone]
  }
}

output "vpc_info" {
  value = local.vpc
}

output "filtered_vpc" {
  value = {
    network_id   = local.vpc.network_id
    subnet_ids   = [for i, id in local.vpc.subnet_ids : id if i != 2]
    subnet_zones = [for i, zone in local.vpc.subnet_zones : zone if i != 2]
  }
}
EOF

























### Задание 8* (необязательное)
Идентифицируйте и устраните намеренно допущенную в tpl-шаблоне ошибку. Обратите внимание, что terraform сам сообщит на какой строке и в какой позиции ошибка!
```
[webservers]
%{~ for i in webservers ~}
${i["name"]} ansible_host=${i["network_interface"][0]["nat_ip_address"] platform_id=${i["platform_id "]}}
%{~ endfor ~}
```----------------------------
Ошибка 1: Незакрытая фигурная скобка
Строка: ${i["network_interface"][0]["nat_ip_address"] platform_id=${i["platform_id "]}}
Позиция: после nat_ip_address отсутствует закрывающая фигурная скобка }

Ошибка 2: Лишний пробел в ключе
Строка: ${i["platform_id "]}
Позиция: в ключе "platform_id " есть лишний пробел в конце


[webservers]
%{ for i in webservers ~}
${i["name"]} ansible_host=${i["network_interface"][0]["nat_ip_address"]} platform_id=${i["platform_id"]}
%{ endfor ~}

1. Создаем файл шаблона с ошибкой

# Создаем директорию templates если её нет
mkdir -p templates

# Создаем файл шаблона с ошибкой (как в вашем примере)
cat > templates/inventory_with_error.tpl << 'EOF'
[webservers]
%{~ for i in webservers ~}
${i["name"]} ansible_host=${i["network_interface"][0]["nat_ip_address"] platform_id=${i["platform_id "]}}
%{~ endfor ~}
EOF

terraform init
terraform apply

# Создать исправленный файл
cat > template_test.tf << 'EOF'
# Локальные переменные с данными ВМ
locals {
  test_webservers = [
    {
      name            = "web-server-1"
      nat_ip_address  = "51.250.66.160"
      platform_id     = "standard-v3"
    },
    {
      name            = "web-server-2" 
      nat_ip_address  = "51.250.88.42"
      platform_id     = "standard-v3"
    }
  ]
}

# Шаблон с НАМЕРЕННОЙ ошибкой
data "template_file" "inventory_with_error" {
  template = file("${path.module}/templates/inventory_with_error.tpl")
  
  vars = {
    webservers = jsonencode(local.test_webservers)
  }
}

# Исправленный шаблон
data "template_file" "inventory_correct" {
  template = file("${path.module}/templates/inventory_correct.tpl")
  
  vars = {
    webservers = jsonencode(local.test_webservers)
  }
}

# Output для проверки
output "template_error" {
  value = data.template_file.inventory_with_error.rendered
}

output "template_correct" {
  value = data.template_file.inventory_correct.rendered
}
EOF

# Шаблон с НАМЕРЕННОЙ ошибкой (с jsondecode)
cat > templates/inventory_with_error.tpl << 'EOF'
[webservers]
%{ for i in jsondecode(webservers) ~}
${i["name"]} ansible_host=${i["nat_ip_address"] platform_id=${i["platform_id "]}}
%{ endfor ~}
EOF

# Исправленный шаблон (с jsondecode)
cat > templates/inventory_correct.tpl << 'EOF'
[webservers]
%{ for i in jsondecode(webservers) ~}
${i["name"]} ansible_host=${i["nat_ip_address"]} platform_id=${i["platform_id"]}
%{ endfor ~}
EOF



### Задание 9* (необязательное)
Напишите  terraform выражения, которые сформируют списки:
1. ["rc01","rc02","rc03","rc04",rc05","rc06",rc07","rc08","rc09","rc10....."rc99"] те список от "rc01" до "rc99"
2. ["rc01","rc02","rc03","rc04",rc05","rc06","rc11","rc12","rc13","rc14",rc15","rc16","rc19"....."rc96"] те список от "rc01" до "rc96", пропуская все номера, заканчивающиеся на "0","7", "8", "9", за исключением "rc19"
--------------------------

1. Список от "rc01" до "rc99"

[for i in range(1, 100) : format("rc%02d", i)]

2. Список от "rc01" до "rc96" с пропуском номеров, оканчивающихся на "0", "7", "8", "9", кроме "rc19"

[for i in range(1, 97) : format("rc%02d", i) if i % 10 != 0 && i % 10 != 7 && i % 10 != 8 && i % 10 != 9 || i == 19]






### Критерии оценки

Зачёт ставится, если:

* выполнены все задания,
* ответы даны в развёрнутой форме,
* приложены соответствующие скриншоты и файлы проекта,
* в выполненных заданиях нет противоречий и нарушения логики.

На доработку работу отправят, если:

* задание выполнено частично или не выполнено вообще,
* в логике выполнения заданий есть противоречия и существенные недостатки. 


